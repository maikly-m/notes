`目录：`
  - [内存
](#f3b21ee0e66a236237912e58399e6213)
    - [内存泄漏
](#896a80f7b937e45db5cd2a1d5584c859)
    - [内存溢出
](#be1589dca81eddd6114d67b07f6cfcab)
    - [内存优化
](#468d681d55ffa50dca6b7097be1d1d6e)
---
## <span id="f3b21ee0e66a236237912e58399e6213"/>内存

- Java 内存管理
- Java 垃圾回收器
- Java 的引用类型
### <span id="896a80f7b937e45db5cd2a1d5584c859"/>内存泄漏

没有用的对象无法回收的现象就是内存泄露

产生的部分原因及解决方法有：

- 单例造成的内存泄露     
  解决方法：使用弱引用；
- 非静态内部类/匿名类    
  解决方法：改为静态内部类
- IO、网络等流未关闭    
  解决方法：关流
- 向单例的管理器类注册接口之后，不使用后没有反注册  
  解决方法：反注册

### <span id="be1589dca81eddd6114d67b07f6cfcab"/>内存溢出


产生的部分原因及解决方法有：

- 内存泄漏，导致内存使用不足；
- 代码编写不当，比如大量使用枚举而不是使用常量来替代；
  大量使用包装类型而不是使用基本数据类型；
  使用第三方库没有做好选型和优化，可能存在加载大量不使用的资源而长期占有内存；
- Bitmap加载没有优化，非常占内存；
- APP整体运行需要较大的内存资源，需要使用多进程来减少内存的使用；

### <span id="468d681d55ffa50dca6b7097be1d1d6e"/>内存优化


- 当界面不可见的时候适当的释放内存，重写Activity的onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发说明用户离开了程序，此时就可以进行资源释放操作了。
- 当内存紧张时释放内存 onTrimMemory()方法还有很多种其他类型的回调，可以在手机内存降低的时候及时通知我们，我们应该根据回调中传入的级别来去决定如何释放应用程序的资源。
- 资源文件需要选择合适的文件夹进行存放,比如不希望拉伸的图片放在nodpi文件夹中
- 谨慎使用static对象。static final和static的区别，仅static是需要方法运行的，而加上final是直接使用的
- 特别留意单例对象中不合理的持有，生命周期不一致的问题
- 珍惜Services资源
- 优化布局层次，重用，需要时加载ViewStub，减少内存消耗
- 谨慎使用“抽象”编程，在Android使用抽象编程会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是也要映射到内存中，不仅占用了更多的内存，在执行效率上也会有所降低。所以需要合理的使用抽象编程。
- 谨慎使用依赖注入框架，因为会加载一些你不需要的东西，很久才会释放
- 谨慎使用多进程
- 使用ProGuard来剔除不需要的代码
- 谨慎使用第三方libraries
- 考虑不同的实现方式来优化内存占用
