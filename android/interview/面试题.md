## 面试题
`目录：`

[java中==和equals和hashCode的区别](#1)     
[int与integer的区别](#2)    
[String、StringBuffer、StringBuilder区别](#3)    
[什么是内部类？内部类的作用](#4)    
[进程和线程的区别](#5)

1. java中==和equals和hashCode的区别 

    <span id="1"/>

    基本数据类型的==比较的值相等.
    
    类的==比较的内存的地址，即是否是同一个对象，在不覆盖equals的情况下，同比较内存地址，原实现也为 == ，如String等重写了equals方法.
    
    hashCode也是Object类的一个方法。返回一个离散的int型整数。在集合类操作中使用，为了提高查询速度。（HashMap，HashSet等比较是否为同一个）
    
    如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。
    
    如果两个对象不equals，他们的hashcode有可能相等。
    
    如果两个对象hashcode相等，他们不一定equals。
    
    如果两个对象hashcode不相等，他们一定不equals。

2. int与integer的区别

    <span id="2"/>

    int 基本类型
    
    integer 对象 int的封装类
3. String、StringBuffer、StringBuilder区别

    <span id="3"/>

    String:字符串常量 不适用于经常要改变值得情况，每次改变相当于生成一个新的对象
    
    StringBuffer:字符串变量 （线程安全）
    
    StringBuilder:字符串变量（线程不安全） 确保单线程下可用，效率略高于StringBuffer
4. 什么是内部类？内部类的作用

    <span id="4"/>

    内部类可直接访问外部类的属性
    
    Java中内部类主要分为成员内部类、局部内部类(嵌套在方法和作用域内)、匿名内部类（没构造方法）、静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法， 不依赖外围类）
5. 进程和线程的区别

    <span id="5"/>

    进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。
    
    进程之间不能共享资源，而线程共享所在进程的地址空间和其它资源。
    
    一个进程内可拥有多个线程，进程可开启进程，也可开启线程。
    
    一个线程只能属于一个进程，线程可直接使用同进程的资源,线程依赖于进程而存在。
6. final，finally，finalize的区别

    final:修饰类、成员变量和成员方法，类不可被继承，成员变量不可变，成员方法不可重写
    
    finally:与try...catch...共同使用，确保无论是否出现异常都能被调用到
    
    finalize:类的方法,垃圾回收之前会调用此方法,子类可以重写finalize()方法实现对资源的回收
7. Serializable 和Parcelable 的区别

    Serializable Java 序列化接口 在硬盘上读写 读写过程中有大量临时变量的生成，内部执行大量的i/o操作，效率很低。
    
    Parcelable Android 序列化接口 效率高 使用麻烦 在内存中读写（AS有相关插件 一键生成所需方法） ，对象不能保存到磁盘中
8. 静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

    可继承 不可重写 而是被隐藏
    
    如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。
    如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成。
9. 成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用

    Java中内部类主要分为成员内部类、局部内部类(嵌套在方法和作用域内)、匿名内部类（没构造方法）、
    静态内部类（static修饰的类，不能使用任何外围类的非static成员变量和方法，不依赖外围类）
    
    使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，
    所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
    
    因为Java不支持多继承，支持实现多个接口。但有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。
